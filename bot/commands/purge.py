import asyncio
import datetime as dt

import discord
from discord import app_commands

from ..config import ALLOWED_USER_IDS, DEFAULT_PURGE_DAYS, PURGE_DM_ENABLED, PURGE_DM_TEMPLATE
from ..helpers import (
    NO_PINGS,
    RoleMode,
    PENDING_PURGES,
    generate_confirm_code,
    normalize_phrase,
    compute_purge_candidates,
    pretty_role_mode,
    send_audit_embed,
    PURGE_CONFIRM_TTL_SECONDS,
    PURGE_KICK_DELAY_SECONDS,
    PURGE_CONFIRM_PHRASE,
    PURGE_GRACE_PERIOD_SECONDS,
    rel_ts,
)
from ..views import SimplePagedView, GraceCancelView


def _render_purge_dm(*, member: discord.Member, guild: discord.Guild, days: int, role_mode: str) -> str:
    """
    Placeholders supported in PURGE_DM_TEMPLATE:
      {user}      -> str(member)
      {server}    -> guild.name
      {days}      -> days threshold used
      {role_mode} -> role_mode string
    """
    return (
        PURGE_DM_TEMPLATE
        .replace("{user}", str(member))
        .replace("{server}", guild.name)
        .replace("{days}", str(days))
        .replace("{role_mode}", str(role_mode))
    )


def setup(bot):
    @bot.tree.command(
        name="purge_eligible",
        description="Kick role-eligible members who joined more than N days ago (multi-step confirmation).",
    )
    @app_commands.describe(
        days="Kick members who joined more than this many days ago (default 7).",
        dry_run="If true, previews + generates a confirm code. If false, requires confirm_code + confirm=true + confirm_phrase.",
        confirm_code="The 6-char code generated by a dry run.",
        confirm="Must be true to actually kick (extra safety).",
        confirm_phrase=f"Must be: {PURGE_CONFIRM_PHRASE} (quotes optional)",
        include_bots="Include bot accounts in candidates (default false).",
        role_mode="Which role combo to target: both (default), redditor_only, or member_only.",
    )
    async def purge_eligible(
        interaction: discord.Interaction,
        days: int = DEFAULT_PURGE_DAYS,
        dry_run: bool = True,
        confirm_code: str | None = None,
        confirm: bool = False,
        confirm_phrase: str | None = None,
        include_bots: bool = False,
        role_mode: RoleMode = "both",
    ):
        if interaction.user.id not in ALLOWED_USER_IDS:
            await interaction.response.send_message("You are not authorized to use this command.", ephemeral=True)
            return

        guild = interaction.guild
        if guild is None:
            await interaction.response.send_message("Run this in a server, not DMs.", ephemeral=True)
            return

        me = guild.me
        if me is None:
            await interaction.response.send_message("Can't resolve bot member in this guild.", ephemeral=True)
            return

        if not interaction.user.guild_permissions.kick_members:
            await interaction.response.send_message("You need Kick Members permission to use this.", ephemeral=True)
            return

        if not me.guild_permissions.kick_members:
            await interaction.response.send_message("I don't have Kick Members permission.", ephemeral=True)
            return

        if days < 1:
            await interaction.response.send_message("Set days to 1 or higher.", ephemeral=True)
            return

        await interaction.response.defer(ephemeral=True)
        key = (guild.id, interaction.user.id)

        # --------------------
        # DRY RUN
        # --------------------
        if dry_run:
            candidates = await compute_purge_candidates(
                guild=guild,
                invoker_id=interaction.user.id,
                bot_id=me.id,
                days=days,
                include_bots=include_bots,
                role_mode=role_mode,
            )

            code = generate_confirm_code()
            PENDING_PURGES[key] = {
                "code": code,
                "created_at": dt.datetime.now(dt.timezone.utc),
                "days": days,
                "include_bots": include_bots,
                "role_mode": role_mode,
                "user_ids": [m.id for m in candidates],
            }

            lines = [f"• {m} {m.mention} — {m.id} — joined {rel_ts(m.joined_at)}" for m in candidates] or ["(none)"]
            pages = []
            cur = ""
            for line in lines:
                add = line + "\n"
                if len(cur) + len(add) > 900:
                    pages.append(cur.rstrip() if cur else "(none)")
                    cur = add
                else:
                    cur += add
            pages.append(cur.rstrip() if cur else "(none)")

            desc = (
                f"Would kick **{len(candidates)}** member(s) who match **role_mode: {pretty_role_mode(role_mode)}** "
                f"and joined **more than {days} day(s) ago**.\n\n"
                f"**Confirm code:** `{code}` (expires in {PURGE_CONFIRM_TTL_SECONDS//60} minutes)\n"
                f"Execute with:\n"
                f"`/purge_eligible days:{days} dry_run:false role_mode:{role_mode} confirm_code:{code} confirm:true confirm_phrase:{PURGE_CONFIRM_PHRASE}`\n\n"
                f"Safety: if the candidate list changes after this preview, the purge auto-cancels and you must re-run dry run."
            )

            view = SimplePagedView(
                author_id=interaction.user.id,
                pages=pages,
                title="Purge preview (dry run)",
                description=desc,
            )
            await interaction.followup.send(embed=view.build_embed(), view=view, ephemeral=True, allowed_mentions=NO_PINGS)
            return

        # --------------------
        # EXECUTE PATH
        # --------------------
        pending = PENDING_PURGES.get(key)
        if not pending:
            await interaction.followup.send(
                "No pending purge found. Run `/purge_eligible dry_run:true` first to generate a confirm code.",
                ephemeral=True,
            )
            return

        created_at: dt.datetime = pending["created_at"]
        age = dt.datetime.now(dt.timezone.utc) - created_at
        if age.total_seconds() > PURGE_CONFIRM_TTL_SECONDS:
            PENDING_PURGES.pop(key, None)
            await interaction.followup.send("That confirm code expired. Run a new dry run.", ephemeral=True)
            return

        if not confirm or not confirm_code:
            await interaction.followup.send(
                "To actually kick, you must provide `confirm:true`, plus the `confirm_code` from the dry run.",
                ephemeral=True,
            )
            return

        if not confirm_phrase or normalize_phrase(confirm_phrase) != PURGE_CONFIRM_PHRASE:
            await interaction.followup.send(
                f"You must provide `confirm_phrase: {PURGE_CONFIRM_PHRASE}` (quotes optional).",
                ephemeral=True,
            )
            return

        if confirm_code.strip().upper() != pending["code"]:
            await interaction.followup.send("Confirm code is wrong. Run a new dry run.", ephemeral=True)
            return

        if days != pending["days"]:
            await interaction.followup.send(
                f"Days mismatch. Your pending code is for days={pending['days']}. Run a new dry run for days={days}.",
                ephemeral=True,
            )
            return

        if include_bots != pending.get("include_bots", False):
            await interaction.followup.send(
                f"include_bots mismatch. Your pending code is for include_bots={pending.get('include_bots', False)}. "
                "Run a new dry run with your desired include_bots setting.",
                ephemeral=True,
            )
            return

        if role_mode != pending.get("role_mode", "both"):
            await interaction.followup.send(
                f"role_mode mismatch. Your pending code is for role_mode={pending.get('role_mode', 'both')}. "
                "Run a new dry run with your desired role_mode.",
                ephemeral=True,
            )
            return

        # Recompute candidates NOW and require EXACT match
        current_candidates = await compute_purge_candidates(
            guild=guild,
            invoker_id=interaction.user.id,
            bot_id=me.id,
            days=days,
            include_bots=include_bots,
            role_mode=role_mode,
        )

        pending_set = set(pending["user_ids"])
        current_set = {m.id for m in current_candidates}

        if current_set != pending_set:
            added = sorted(current_set - pending_set)
            removed = sorted(pending_set - current_set)
            PENDING_PURGES.pop(key, None)

            def fmt_ids(ids: list[int], limit: int = 10) -> str:
                if not ids:
                    return "(none)"
                shown = ids[:limit]
                more = len(ids) - len(shown)
                s = ", ".join(str(x) for x in shown)
                return s + (f" …(+{more} more)" if more > 0 else "")

            embed = discord.Embed(
                title="Purge cancelled (candidate list changed)",
                description=(
                    "Between your dry run and execution, the set of eligible members changed.\n"
                    "This purge was cancelled to ensure you only kick the exact people you reviewed.\n\n"
                    f"**Added since dry run:** {len(added)}\n"
                    f"**Removed since dry run:** {len(removed)}\n\n"
                    "Run `/purge_eligible dry_run:true` again to review the updated list and get a new confirm code."
                ),
            )
            embed.add_field(name="Added user IDs (sample)", value=fmt_ids(added), inline=False)
            embed.add_field(name="Removed user IDs (sample)", value=fmt_ids(removed), inline=False)
            await interaction.followup.send(embed=embed, ephemeral=True, allowed_mentions=NO_PINGS)
            return

        # Candidate set matches exactly what was reviewed. Clear pending now so it can't be reused.
        PENDING_PURGES.pop(key, None)

        to_kick = current_candidates
        if not to_kick:
            await interaction.followup.send("No candidates are still in the server. Nothing to do.", ephemeral=True)
            return

        # --------------------
        # GRACE PERIOD (CANCEL BUTTON)
        # --------------------
        start_at = dt.datetime.now(dt.timezone.utc) + dt.timedelta(seconds=PURGE_GRACE_PERIOD_SECONDS)
        grace_embed = discord.Embed(
            title="Purge armed",
            description=(
                f"About to kick **{len(to_kick)}** member(s) (joined > {days} days ago; role_mode: {pretty_role_mode(role_mode)}).\n\n"
                f"Starts {rel_ts(start_at)}.\n"
                f"Click **Cancel purge** to abort."
            ),
        )
        grace_view = GraceCancelView(author_id=interaction.user.id)
        await interaction.followup.send(embed=grace_embed, view=grace_view, ephemeral=True, allowed_mentions=NO_PINGS)

        armed_audit = discord.Embed(
            title="Purge armed",
            description=(
                f"Invoker: {interaction.user} ({interaction.user.id})\n"
                f"Days: {days}\n"
                f"Role mode: {role_mode}\n"
                f"Candidates: {len(to_kick)}\n"
                f"Grace: {PURGE_GRACE_PERIOD_SECONDS}s\n"
                f"Starts: {start_at.isoformat()}\n"
                f"Purge DM: {'enabled' if (PURGE_DM_ENABLED and PURGE_DM_TEMPLATE) else 'disabled'}"
            ),
        )
        await send_audit_embed(guild, armed_audit)

        try:
            await asyncio.wait_for(grace_view.cancel_event.wait(), timeout=PURGE_GRACE_PERIOD_SECONDS)
            cancelled_audit = discord.Embed(
                title="Purge cancelled during grace period",
                description=(
                    f"Invoker: {interaction.user} ({interaction.user.id})\n"
                    f"Days: {days}\n"
                    f"Role mode: {role_mode}\n"
                    f"Candidates (planned): {len(to_kick)}\n"
                ),
            )
            await send_audit_embed(guild, cancelled_audit)
            return
        except asyncio.TimeoutError:
            pass

        # --------------------
        # START KICKING
        # --------------------
        running_embed = discord.Embed(
            title="Purge started",
            description=(
                f"Kicking **{len(to_kick)}** member(s).\n"
                f"Role mode: **{pretty_role_mode(role_mode)}**\n"
                f"Throttling at ~{PURGE_KICK_DELAY_SECONDS:.1f}s per kick."
            ),
        )
        await interaction.followup.send(embed=running_embed, ephemeral=True, allowed_mentions=NO_PINGS)

        started_audit = discord.Embed(
            title="Purge started",
            description=(
                f"Invoker: {interaction.user} ({interaction.user.id})\n"
                f"Days: {days}\n"
                f"Role mode: {role_mode}\n"
                f"Candidates: {len(to_kick)}\n"
                f"Purge DM: {'enabled' if (PURGE_DM_ENABLED and PURGE_DM_TEMPLATE) else 'disabled'}"
            ),
        )
        await send_audit_embed(guild, started_audit)

        kicked = 0
        failed: list[str] = []

        dm_sent_count = 0
        dm_failed_count = 0

        for m in to_kick:
            # DM attempt before kick (env-only)
            if PURGE_DM_ENABLED and PURGE_DM_TEMPLATE:
                try:
                    msg = _render_purge_dm(member=m, guild=guild, days=days, role_mode=str(role_mode))
                    await m.send(msg, allowed_mentions=NO_PINGS)
                    dm_sent_count += 1
                except Exception:
                    dm_failed_count += 1

            try:
                await m.kick(reason=f"Purge: role_mode={role_mode} and joined > {days} days ago (by {interaction.user.id})")
                kicked += 1
            except discord.Forbidden:
                failed.append(f"{m} ({m.id}) — forbidden (role hierarchy / perms)")
            except discord.HTTPException as e:
                failed.append(f"{m} ({m.id}) — http error: {e.status}")
            await asyncio.sleep(PURGE_KICK_DELAY_SECONDS)

        done_embed = discord.Embed(
            title="Purge complete",
            description=(
                f"Kicked **{kicked}** / **{len(to_kick)}** member(s).\n"
                f"Purge DMs — sent: **{dm_sent_count}**, failed: **{dm_failed_count}**"
            ),
        )

        if failed:
            snippet_lines = [f"• {x}" for x in failed[:10]]
            snippet = "\n".join(snippet_lines) if snippet_lines else "(none)"
            if len(failed) > 10:
                snippet += f"\n… and {len(failed) - 10} more"
            done_embed.add_field(name="Failed kicks (top 10)", value=snippet[:1024], inline=False)

        await interaction.followup.send(embed=done_embed, ephemeral=True, allowed_mentions=NO_PINGS)

        finished_audit = discord.Embed(
            title="Purge complete",
            description=(
                f"Invoker: {interaction.user} ({interaction.user.id})\n"
                f"Days: {days}\n"
                f"Role mode: {role_mode}\n"
                f"Kicked: {kicked}/{len(to_kick)}\n"
                f"Failures: {len(failed)}\n"
                f"Purge DMs: sent={dm_sent_count}, failed={dm_failed_count}\n"
            ),
        )
        await send_audit_embed(guild, finished_audit)
